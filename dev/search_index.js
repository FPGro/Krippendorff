var documenterSearchIndex = {"docs":
[{"location":"importantFunctions/#The-Krippendorff-Module","page":"Important Functions","title":"The Krippendorff Module","text":"","category":"section"},{"location":"importantFunctions/","page":"Important Functions","title":"Important Functions","text":"Currently, there are two computational backends:  If the number of possible responses is bounded, one can construct a coincidence matrix with all observed pairs. Computing the observed disagreement is straightforward in this case, while the expected disagreement can easily be cpmputed from the marginals of the coincidence matrix.  For all other cases, a generical computation strategy was implemented which avoids constructing temporary tables entirely, but typically scales much worse. ","category":"page"},{"location":"importantFunctions/#Detailed-API","page":"Important Functions","title":"Detailed API","text":"","category":"section"},{"location":"importantFunctions/","page":"Important Functions","title":"Important Functions","text":"krippendorffs_alpha\nKrippendorff.compute_alpha_with_coincidences\nKrippendorff.compute_alpha_generical\nKrippendorff.prepare_iterator\nKrippendorff.istable","category":"page"},{"location":"importantFunctions/#Krippendorff.krippendorffs_alpha","page":"Important Functions","title":"Krippendorff.krippendorffs_alpha","text":"Krippendorff.alpha(...)\nkrippendorffs_alpha(input; units = rows, metric = :nominal, R = :discrete, silent = false)\n\nCompute the Krippendorff's-α inter-rater reliability measure from the supplied input. The input will  be checked to determine how to iterate over it, missing values will be handled automatically if present  and the most efficient algorithm to compute α will be determined heuristically. By default, Tables.jl  tables and table-like inputs are assumed to have columns representing raters and rows representing units. See prepare_iterator for more information about the input requirements.\n\nArguments\n\nunits::Union{Symbol,AbstractString}: rows or col(umn)s, see prepare_iterator for explanation\nmetric: a metric computing the squared distance between any pair of responses. Any of [:nominal, :interval] or a custom function. Should satisfy f(x,y) = [0 if x==y], [>0 otherwise] but this is not enforced. See README for explanation of the default metrics.\nR: The space of possible responses. Either :discrete (relatively few possible responses, uses fast computation via coincidence matrix), :continuous (many possible responses up to continuous range, uses a slower but generically applicable algorithm with minimal allocation) or a precomputed value (implies discrete, but avoids searching for all unique values). If precomputed, it should be supplied as a tuple or vector of possible values (e.g. the output of unique(yourdata)), or as an appropriate range object where possible (slightly more efficient). \nsilent::Bool: set to disable all optional output (@info and @warn, doesn't affect error messages)\n\nSee also: compute_alpha_generical, compute_alpha_with_coincidences\n\n\n\n\n\n","category":"function"},{"location":"importantFunctions/#Krippendorff.compute_alpha_with_coincidences","page":"Important Functions","title":"Krippendorff.compute_alpha_with_coincidences","text":"compute_alpha_with_coincidences(units, metric, possible_responses)\n\nThe default fast computation backend for Krippendorffs alpha. This will iterate over all units only once and thus scales preferably if the number of differing possible responses is bounded. A coincidence matrix is generated to keep track of the observed disagreement, while the expected disagreement will be computed from the marginals of the coincidence matrix. Be careful, if the number of possible responses is large, this backend may allocate a lot! \n\nArguments\n\nunits_iterator: An iterable object which is assumed to yield units with no missings. If this is not the case, you can call prepare_iterator on it.\nsquared_distance_metric: An object callable on any pair of possible responses in the supplied iterator. Should satisfy f(x,y) = [0 if x==y], [>0 otherwise] but this is not checked explicitly.\nR: Space of possible responses. This is necessary to generate the coincidence matrix efficiently. It should be supplied as a tuple or vector of possible values (e.g. the output of unique(yourdata)), or as an appropriate range object where possible. \n\n\n\n\n\n","category":"function"},{"location":"importantFunctions/#Krippendorff.compute_alpha_generical","page":"Important Functions","title":"Krippendorff.compute_alpha_generical","text":"compute_alpha_generical(units_iterator, squared_distance_metric)\n\nGeneric computation backend for Krippendorffs alpha, bypassing the creation of coincidence tables entirely. The tradeof in this case is the necessity to iterate over all pairs of units. Thus, scaling is typically much worse (in O(U²*R) for (U)nits and (R)aters) than when using coicidence matrices. Nonetheless, this backend will be used by default if the number of possible responses is large  compared to the size of the input, since a coincidence matrix can get huge in this case. It is also preferable when all possible responses are not known beforehand or span a continuous spectrum of values. \n\nArguments\n\nunits_iterator: An iterable object which is assumed to yield units with no missings. If this is not the case, you can call prepare_iterator on it.\nsquared_distance_metric: An object callable on any pair of possible responses in the supplied iterator. Should satisfy f(x,y) = [0 if x==y], [>0 otherwise] but this is not checked explicitly.\n\n\n\n\n\n","category":"function"},{"location":"importantFunctions/#Krippendorff.prepare_iterator","page":"Important Functions","title":"Krippendorff.prepare_iterator","text":"prepare_iterator(input; units = rows)\n\nPrepare an object for iteration by one of the compute_alpha_... functions.  This involves determining how to iterate over units in the object and probing for the elementtype. If appropriate, the units argument is used to determine the direction of iteration. This is however not always possible. If no sense of direction is found, the heuristic will assume the input is already a suitable iterator over units. Furthermore, if the input is found to contain missing values (or has them in it's eltype), all units will be wrapped in skipmissing automatically.\n\nSince some seemingly unstructured iterables can satisfy the Tables.jl interface somewhat surprisingly (Dict{Symbol,Vector} does, but not Dict{String,Vector} for example) and this may change the order of  iteration implied, you can call the helper function Krippendorff.istable to see whether your input looks like a table and if yes, how many rows and columns it appears to have.\n\nArguments\n\ninput: The input to be prepared. Should support generic iteration via iterate, eachrow or eachcol or satisfy the Tables.jl interface as determined by Tables.istable.\nunits::Union{Symbol,AbstractString}: either rows or col(umn)s. This is used to determine how to iterate units in the input. For example, if the input iterator was a Matrix, :rows would make the function call eachrow(input) (and a little bit more). \n\n\n\n\n\n","category":"function"},{"location":"importantFunctions/#Krippendorff.istable","page":"Important Functions","title":"Krippendorff.istable","text":"istable(input; IO = stdout)\n\nA thin wrapper around Tables.istable that additionally prints how man rows and columns the input appears to have when iterated through the Tables.jl interface. (Tables.columns specifically) IO can be used to redirect the written output. Pass IO=devnull to supress output (making it equivalent to calling Tables.istable\n\nExamples\n\nThe Tables.jl interface assumes named columns and unnamed rows, which may lead to confusion  if one wanted to pass a dictionary of rows for examples:\n\njulia> testmatrix = reshape(1:15, (3,5))\n3×5 reshape(::UnitRange{Int64}, 3, 5) with eltype Int64:\n 1  4  7  10  13\n 2  5  8  11  14\n 3  6  9  12  15\n\njulia> Krippendorff.istable(testmatrix)\nfalse\n\njulia> Krippendorff.istable(Tables.table(testmatrix));\nInput satisfies the Tables.jl table interface and appears to have 3 rows and 5 columns.\n\njulia> testvectordict = Dict([k=>v for (k,v) in zip([:row1, :row2, :row3], eachrow(testmatrix))]); [println(entry) for entry in testvectordict];\n:row1 => [1, 4, 7, 10, 13]\n:row2 => [2, 5, 8, 11, 14]\n:row3 => [3, 6, 9, 12, 15]\n\njulia> Krippendorff.istable(testvectordict)\nInput satisfies the Tables.jl table interface and appears to have 5 rows and 3 columns.\ntrue\n\n\n\n\n\n","category":"function"},{"location":"about/#The-package","page":"About","title":"The package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The package was developed in conjunction with a bigger project, because there was no implementation of Krippendorff's alpha until now. (I didn't find one at least)","category":"page"},{"location":"about/","page":"About","title":"About","text":"For those who are curious, the framework described in the following paper is currently being implemented in Julia:","category":"page"},{"location":"about/","page":"About","title":"About","text":"T. Schmid,  Using Learning Algorithms to Create, Exploit and Maintain Knowledge Bases: Principles of Constructivist Machine Learning,  Proceedings of the AAAI 2020 Spring Symposium on Combining Machine Learning and Knowledge Engineering in Practice (AAAI-MAKE 2020).  Stanford University, Palo Alto, California, USA, March 23-25, 2020.  Link: http://ceur-ws.org/Vol-2600/paper11.pdf","category":"page"},{"location":"about/#The-maintainer","page":"About","title":"The maintainer","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Is currently employed by the University of Leipzig, Germany. I'm reachable via GitHub, the Julia Zulip and Discourse and mail: f.grosse<at>studserv.uni-leipzig.de","category":"page"},{"location":"about/#Special-Thanks","page":"About","title":"Special Thanks","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Goes to Antonello Lobianco, for his Julia tutorial repository and GitBook, the section on Developing Julia Package which helped me out a lot in creating this package and setting up documentation and CI. Thank you.","category":"page"},{"location":"about/","page":"About","title":"About","text":"A. Lobianco, (2018), “Julia language: a concise tutorial\", GitBook, https://syl1.gitbook.io/julia-language-a-concise-tutorial, retrieved 28/01/2021","category":"page"},{"location":"#Krippendorff.jl","page":"Krippendorffs Alpha","title":"Krippendorff.jl","text":"","category":"section"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Welcome to Krippendorff.jl,","category":"page"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"this package provides a pure Julia implementation of the Krippendorff's alpha inter-rater reliability measure.","category":"page"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Krippendorff","category":"page"},{"location":"#Krippendorff","page":"Krippendorffs Alpha","title":"Krippendorff","text":"Krippendorff.jl\n\nKrippendorff's alpha in Julia\n\nThis package aims to provide easy access to the afforementioned inter-rater reliability measure. The main entry point (and sole exported function) is krippendorffs_alpha, which provides an  easy-to-use interface for most requirements. alpha is the unexported alias for krippendorffs_alpha, allowing the usage of Krippendorff.alpha. \n\nAlpha is used to quantify the amount of agreement or disagreement of a number of raters that assign values (responses) to different units (subjects/tasks) according to a common code. It is conceptually similar to other measures like Cohen's κ, Scott's π, Fleiss' κ or intra-class correlation, but is more generally applicable. Alpha can be computer for any number of raters and units, allows for missing values, is corrected for small sample sizes and works with various levels of measurement, which govern the  distance metric that is used in the computation. Thus, alpha works with nominal, ordinal, interval,  (bi)polar, circular and ratio variables. (and possibly more)\n\nThe high-level function will just work with most data. Inputs are required to either be iterable julia objects or satisfy the Tables.jl interface (as  determined by Tables.istable), in which case they will be accessed via Tables.rows or Tables.columns. Missing values are handled and the algorithm tries to determine the set of possible responses  automatically. Depending on these, one of currently two computational backends is choosen to compute  alpha. Thin wrappers around these backends with proper documentation are compute_alpha_generical and compute_alpha_with_coincidences.\n\nReferences\n\nKrippendorff, Klaus. (2011). Computing Krippendorff's Alpha-Reliability. Retrieved from https://repository.upenn.edu/asc_papers/43\nHayes, Andrew & Krippendorff, Klaus. (2007). Answering the Call for a Standard Reliability Measure for Coding Data. Communication Methods and Measures. 1. 77-89. 10.1080/19312450709336664. \n\n\n\n\n\n","category":"module"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Most of the code was modeled directly after Krippendorffs explanations in the first reference above.","category":"page"},{"location":"#Module-Index","page":"Krippendorffs Alpha","title":"Module Index","text":"","category":"section"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Modules = [Krippendorff]\nOrder   = [:constant, :type, :function, :macro]","category":"page"}]
}
