var documenterSearchIndex = {"docs":
[{"location":"importantFunctions/#The-Krippendorff-Module","page":"Important Functions","title":"The Krippendorff Module","text":"","category":"section"},{"location":"importantFunctions/","page":"Important Functions","title":"Important Functions","text":"Currently, there are two computational backends:  If the number of possible responses is bounded, one can construct a coincidence matrix with all observed pairs. Computing the observed disagreement is straightforward in this case, while the expected disagreement can easily be cpmputed from the marginals of the coincidence matrix.  For all other cases, a generical computation strategy was implemented which avoids constructing temporary tables entirely, but typically scales much worse. ","category":"page"},{"location":"importantFunctions/#Detailed-API","page":"Important Functions","title":"Detailed API","text":"","category":"section"},{"location":"importantFunctions/","page":"Important Functions","title":"Important Functions","text":"krippendorffs_alpha\ncompute_alpha_with_coincidences\ncompute_alpha_generical\nprepare_iterator\nistable","category":"page"},{"location":"importantFunctions/#Krippendorff.krippendorffs_alpha","page":"Important Functions","title":"Krippendorff.krippendorffs_alpha","text":"Krippendorff.alpha(...)\nkrippendorffs_alpha(input; units = rows, metric = :nominal, R = :discrete, silent = false)\n\nCompute the Krippendorff's-α inter-rater reliability measure from the supplied input. The input will  be checked to determine how to iterate over it, missing values will be handled automatically if present  and the most efficient algorithm to compute α will be determined heuristically. By default, Tables.jl  tables and table-like inputs are assumed to have columns representing raters and rows representing units. See prepare_iterator for more information about the input requirements.\n\nArguments\n\nunits::Union{Symbol,AbstractString}: rows or col(umn)s, see prepare_iterator for explanation\nmetric: a metric computing the squared distance between any pair of responses. Any of [:nominal, :interval] or a custom function. Should satisfy f(x,y) = [0 if x==y], [>0 otherwise] but this is not enforced. See README for explanation of the default metrics.\nR: The space of possible responses. Either :discrete (relatively few possible responses, uses fast computation via coincidence matrix), :continuous (many possible responses up to continuous range, uses a slower but generically applicable algorithm with minimal allocation) or a precomputed value (implies discrete, but avoids searching for all unique values). If precomputed, it should be supplied as a tuple or vector of possible values (e.g. the output of unique(yourdata)), or as an appropriate range object where possible (slightly more efficient). \nsilent::Bool: set to disable all optional output (@info and @warn, doesn't affect error messages)\n\nSee also: compute_alpha_generical, compute_alpha_with_coincidences\n\n\n\n\n\n","category":"function"},{"location":"about/#The-package","page":"About","title":"The package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The package was developed in conjunction with a bigger project, because there was no implementation of Krippendorff's alpha until now. (I didn't find one at least)","category":"page"},{"location":"about/","page":"About","title":"About","text":"For those who are curious, the framework described in the following paper is currently being implemented in Julia:","category":"page"},{"location":"about/","page":"About","title":"About","text":"T. Schmid,  Using Learning Algorithms to Create, Exploit and Maintain Knowledge Bases: Principles of Constructivist Machine Learning,  Proceedings of the AAAI 2020 Spring Symposium on Combining Machine Learning and Knowledge Engineering in Practice (AAAI-MAKE 2020).  Stanford University, Palo Alto, California, USA, March 23-25, 2020.  Link: http://ceur-ws.org/Vol-2600/paper11.pdf","category":"page"},{"location":"about/#The-maintainer","page":"About","title":"The maintainer","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Is currently employed by the University of Leipzig, Germany. I'm reachable via GitHub, the Julia Zulip and Discourse and mail: f.grosse<at>studserv.uni-leipzig.de","category":"page"},{"location":"#Krippendorff.jl","page":"Krippendorffs Alpha","title":"Krippendorff.jl","text":"","category":"section"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Welcome to Krippendorff.jl,","category":"page"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"this package provides a pure Julia implementation of the Krippendorff's alpha inter-rater reliability measure.","category":"page"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Krippendorff","category":"page"},{"location":"#Krippendorff","page":"Krippendorffs Alpha","title":"Krippendorff","text":"Krippendorff.jl\n\nKrippendorff's alpha in Julia\n\nThis package aims to provide easy access to the afforementioned inter-rater reliability measure. The main entry point (and sole exported function) is krippendorffs_alpha, which provides an  easy-to-use interface for most requirements. alpha is the unexported alias for krippendorffs_alpha, allowing the usage of Krippendorff.alpha. \n\nAlpha is used to quantify the amount of agreement or disagreement of a number of raters that assign values (responses) to different units (subjects/tasks) according to a common code. It is conceptually similar to other measures like Cohen's κ, Scott's π, Fleiss' κ or intra-class correlation, but is more generally applicable. Alpha can be computer for any number of raters and units, allows for missing values, is corrected for small sample sizes and works with various levels of measurement, which govern the  distance metric that is used in the computation. Thus, alpha works with nominal, ordinal, interval,  (bi)polar, circular and ratio variables. (and possibly more)\n\nThe high-level function will just work with most data. Inputs are required to either be iterable julia objects or satisfy the Tables.jl interface (as  determined by Tables.istable), in which case they will be accessed via Tables.rows or Tables.columns. Missing values are handled and the algorithm tries to determine the set of possible responses  automatically. Depending on these, one of currently two computational backends is choosen to compute  alpha. Thin wrappers around these backends with proper documentation are compute_alpha_generical and compute_alpha_with_coincidences.\n\nReferences\n\nKrippendorff, Klaus. (2011). Computing Krippendorff's Alpha-Reliability. Retrieved from https://repository.upenn.edu/asc_papers/43\nHayes, Andrew & Krippendorff, Klaus. (2007). Answering the Call for a Standard Reliability Measure for Coding Data. Communication Methods and Measures. 1. 77-89. 10.1080/19312450709336664. \n\n\n\n\n\n","category":"module"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Most of the code was modeled directly after Krippendorffs explanations in the first reference above.","category":"page"},{"location":"#Module-Index","page":"Krippendorffs Alpha","title":"Module Index","text":"","category":"section"},{"location":"","page":"Krippendorffs Alpha","title":"Krippendorffs Alpha","text":"Modules = [Krippendorff]\nOrder   = [:constant, :type, :function, :macro]","category":"page"}]
}
